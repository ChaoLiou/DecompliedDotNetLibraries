namespace System.Dynamic
{
    using System;
    using System.Runtime.CompilerServices;

    internal static class UpdateDelegates
    {
        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch0<TRet>(CallSite site)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch1<T0, TRet>(CallSite site, T0 arg0)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch2<T0, T1, TRet>(CallSite site, T0 arg0, T1 arg1)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch3<T0, T1, T2, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch4<T0, T1, T2, T3, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch5<T0, T1, T2, T3, T4, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch6<T0, T1, T2, T3, T4, T5, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch7<T0, T1, T2, T3, T4, T5, T6, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch8<T0, T1, T2, T3, T4, T5, T6, T7, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet NoMatch9<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            site._match = false;
            return default(TRet);
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid1<T0>(CallSite site, T0 arg0)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid2<T0, T1>(CallSite site, T0 arg0, T1 arg1)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid3<T0, T1, T2>(CallSite site, T0 arg0, T1 arg1, T2 arg2)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid4<T0, T1, T2, T3>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid5<T0, T1, T2, T3, T4>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid6<T0, T1, T2, T3, T4, T5>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid7<T0, T1, T2, T3, T4, T5, T6>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid8<T0, T1, T2, T3, T4, T5, T6, T7>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void NoMatchVoid9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            site._match = false;
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute0<TRet>(CallSite site)
        {
            Func<CallSite, TRet> func;
            TRet local;
            CallSite<Func<CallSite, TRet>> site2 = (CallSite<Func<CallSite, TRet>>) site;
            Func<CallSite, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, TRet>>(site2);
            Func<CallSite, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[0];
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, TRet>>(site2, args);
                try
                {
                    local = func(site);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute1<T0, TRet>(CallSite site, T0 arg0)
        {
            Func<CallSite, T0, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, TRet>> site2 = (CallSite<Func<CallSite, T0, TRet>>) site;
            Func<CallSite, T0, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, TRet>>(site2);
            Func<CallSite, T0, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> site2 = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>) site;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>(site2);
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute2<T0, T1, TRet>(CallSite site, T0 arg0, T1 arg1)
        {
            Func<CallSite, T0, T1, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, T1, TRet>> site2 = (CallSite<Func<CallSite, T0, T1, TRet>>) site;
            Func<CallSite, T0, T1, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, T1, TRet>>(site2);
            Func<CallSite, T0, T1, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, T1, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0, arg1);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, T1, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, T1, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, T1, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0, arg1);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, T1, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0, arg1 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, T1, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0, arg1);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute3<T0, T1, T2, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2)
        {
            Func<CallSite, T0, T1, T2, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, T1, T2, TRet>> site2 = (CallSite<Func<CallSite, T0, T1, T2, TRet>>) site;
            Func<CallSite, T0, T1, T2, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, T1, T2, TRet>>(site2);
            Func<CallSite, T0, T1, T2, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, T1, T2, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0, arg1, arg2);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, T1, T2, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, T1, T2, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, T1, T2, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0, arg1, arg2);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, T1, T2, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0, arg1, arg2 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, T1, T2, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0, arg1, arg2);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute4<T0, T1, T2, T3, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
        {
            Func<CallSite, T0, T1, T2, T3, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, T1, T2, T3, TRet>> site2 = (CallSite<Func<CallSite, T0, T1, T2, T3, TRet>>) site;
            Func<CallSite, T0, T1, T2, T3, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, T1, T2, T3, TRet>>(site2);
            Func<CallSite, T0, T1, T2, T3, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, T1, T2, T3, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0, arg1, arg2, arg3);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, T1, T2, T3, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, T1, T2, T3, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, T1, T2, T3, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, T1, T2, T3, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, T1, T2, T3, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute5<T0, T1, T2, T3, T4, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            Func<CallSite, T0, T1, T2, T3, T4, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, T1, T2, T3, T4, TRet>> site2 = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, TRet>>) site;
            Func<CallSite, T0, T1, T2, T3, T4, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, T1, T2, T3, T4, TRet>>(site2);
            Func<CallSite, T0, T1, T2, T3, T4, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, T1, T2, T3, T4, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0, arg1, arg2, arg3, arg4);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, T1, T2, T3, T4, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, T1, T2, T3, T4, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, T1, T2, T3, T4, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, T1, T2, T3, T4, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, T1, T2, T3, T4, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute6<T0, T1, T2, T3, T4, T5, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            Func<CallSite, T0, T1, T2, T3, T4, T5, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>> site2 = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>) site;
            Func<CallSite, T0, T1, T2, T3, T4, T5, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>(site2);
            Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0, arg1, arg2, arg3, arg4, arg5);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute7<T0, T1, T2, T3, T4, T5, T6, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> site2 = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>) site;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>(site2);
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute8<T0, T1, T2, T3, T4, T5, T6, T7, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> site2 = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>) site;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>(site2);
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute9<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> func;
            TRet local;
            CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> site2 = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>) site;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>(site2);
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>[] rules = CallSiteOps.GetRules<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    func = rules[j];
                    if (func != target)
                    {
                        site2.Target = func;
                        local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>(site2, j);
                            return local;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> ruleCache = CallSiteOps.GetRuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                func = rules[i];
                site2.Target = func;
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>(site2, func);
                        CallSiteOps.MoveRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>(ruleCache, func, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            func = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };
            while (true)
            {
                site2.Target = target;
                func = site2.Target = site2.Binder.BindCore<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>(site2, args);
                try
                {
                    local = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return local;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>(site2, func);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid1<T0>(CallSite site, T0 arg0)
        {
            Action<CallSite, T0> action;
            CallSite<Action<CallSite, T0>> site2 = (CallSite<Action<CallSite, T0>>) site;
            Action<CallSite, T0> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0>>(site2);
            Action<CallSite, T0>[] rules = CallSiteOps.GetRules<Action<CallSite, T0>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0>>(site2, args);
                try
                {
                    action(site, arg0);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> action;
            CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>> site2 = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>) site;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>(site2);
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>[] rules = CallSiteOps.GetRules<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>(site2, args);
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid2<T0, T1>(CallSite site, T0 arg0, T1 arg1)
        {
            Action<CallSite, T0, T1> action;
            CallSite<Action<CallSite, T0, T1>> site2 = (CallSite<Action<CallSite, T0, T1>>) site;
            Action<CallSite, T0, T1> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0, T1>>(site2);
            Action<CallSite, T0, T1>[] rules = CallSiteOps.GetRules<Action<CallSite, T0, T1>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0, arg1);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0, T1>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0, T1>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0, T1>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0, arg1);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0, T1>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0, arg1 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0, T1>>(site2, args);
                try
                {
                    action(site, arg0, arg1);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid3<T0, T1, T2>(CallSite site, T0 arg0, T1 arg1, T2 arg2)
        {
            Action<CallSite, T0, T1, T2> action;
            CallSite<Action<CallSite, T0, T1, T2>> site2 = (CallSite<Action<CallSite, T0, T1, T2>>) site;
            Action<CallSite, T0, T1, T2> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0, T1, T2>>(site2);
            Action<CallSite, T0, T1, T2>[] rules = CallSiteOps.GetRules<Action<CallSite, T0, T1, T2>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0, arg1, arg2);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0, T1, T2>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0, T1, T2>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0, T1, T2>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0, arg1, arg2);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0, T1, T2>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0, arg1, arg2 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0, T1, T2>>(site2, args);
                try
                {
                    action(site, arg0, arg1, arg2);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid4<T0, T1, T2, T3>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
        {
            Action<CallSite, T0, T1, T2, T3> action;
            CallSite<Action<CallSite, T0, T1, T2, T3>> site2 = (CallSite<Action<CallSite, T0, T1, T2, T3>>) site;
            Action<CallSite, T0, T1, T2, T3> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0, T1, T2, T3>>(site2);
            Action<CallSite, T0, T1, T2, T3>[] rules = CallSiteOps.GetRules<Action<CallSite, T0, T1, T2, T3>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0, arg1, arg2, arg3);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0, T1, T2, T3>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0, T1, T2, T3>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0, T1, T2, T3>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0, arg1, arg2, arg3);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0, T1, T2, T3>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0, T1, T2, T3>>(site2, args);
                try
                {
                    action(site, arg0, arg1, arg2, arg3);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid5<T0, T1, T2, T3, T4>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            Action<CallSite, T0, T1, T2, T3, T4> action;
            CallSite<Action<CallSite, T0, T1, T2, T3, T4>> site2 = (CallSite<Action<CallSite, T0, T1, T2, T3, T4>>) site;
            Action<CallSite, T0, T1, T2, T3, T4> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0, T1, T2, T3, T4>>(site2);
            Action<CallSite, T0, T1, T2, T3, T4>[] rules = CallSiteOps.GetRules<Action<CallSite, T0, T1, T2, T3, T4>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0, arg1, arg2, arg3, arg4);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0, T1, T2, T3, T4>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0, T1, T2, T3, T4>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0, T1, T2, T3, T4>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0, T1, T2, T3, T4>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0, T1, T2, T3, T4>>(site2, args);
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid6<T0, T1, T2, T3, T4, T5>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            Action<CallSite, T0, T1, T2, T3, T4, T5> action;
            CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5>> site2 = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5>>) site;
            Action<CallSite, T0, T1, T2, T3, T4, T5> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0, T1, T2, T3, T4, T5>>(site2);
            Action<CallSite, T0, T1, T2, T3, T4, T5>[] rules = CallSiteOps.GetRules<Action<CallSite, T0, T1, T2, T3, T4, T5>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0, arg1, arg2, arg3, arg4, arg5);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0, T1, T2, T3, T4, T5>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0, T1, T2, T3, T4, T5>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0, T1, T2, T3, T4, T5>>(site2, args);
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid7<T0, T1, T2, T3, T4, T5, T6>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6> action;
            CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>> site2 = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>) site;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>(site2);
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6>[] rules = CallSiteOps.GetRules<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>(site2, args);
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid8<T0, T1, T2, T3, T4, T5, T6, T7>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7> action;
            CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>> site2 = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>) site;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>(site2);
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>[] rules = CallSiteOps.GetRules<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>(site2, args);
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }

        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8> action;
            CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>> site2 = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>) site;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8> target = site2.Target;
            site = CallSiteOps.CreateMatchmaker<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>(site2);
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>[] rules = CallSiteOps.GetRules<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>(site2);
            if (rules != null)
            {
                for (int j = 0; j < rules.Length; j++)
                {
                    action = rules[j];
                    if (action != target)
                    {
                        site2.Target = action;
                        action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                        if (CallSiteOps.GetMatch(site))
                        {
                            CallSiteOps.UpdateRules<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>(site2, j);
                            return;
                        }
                        CallSiteOps.ClearMatch(site);
                    }
                }
            }
            RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>> ruleCache = CallSiteOps.GetRuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>(site2);
            rules = ruleCache.GetRules();
            for (int i = 0; i < rules.Length; i++)
            {
                action = rules[i];
                site2.Target = action;
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (CallSiteOps.GetMatch(site))
                    {
                        return;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>(site2, action);
                        CallSiteOps.MoveRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>(ruleCache, action, i);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
            action = null;
            object[] args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };
            while (true)
            {
                site2.Target = target;
                action = site2.Target = site2.Binder.BindCore<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>(site2, args);
                try
                {
                    action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (CallSiteOps.GetMatch(site))
                    {
                        break;
                    }
                }
                finally
                {
                    if (CallSiteOps.GetMatch(site))
                    {
                        CallSiteOps.AddRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>(site2, action);
                    }
                }
                CallSiteOps.ClearMatch(site);
            }
        }
    }
}

